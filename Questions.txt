1. В классе Connection есть функция checkLoginPassword, которая вызвается из контроллера диалогового окна
входа на сервер LoginController и отправляет на сервер пакет с запросом залогиниться и логином. В ответ сервер
присылает сгенерированный случайным образом код запроса. На базе этого кода и пароля вычисляется ответный код
и отправляется на сервер, где сравнивается с ответным кодом, вычисленным на стороне сервера. Алгоритм расчёта
на стороне сервера и клиента одинаковый, и при одинаковых кодах запроса и паролях получается одинаковый ответный
код. Если ответный код от клиента и ответный код, вычисленный на сервере, совпдают, то пароль введён верно,
и сервер даёт добро на вход в систему для указанного логина и сообщает об этом клиенту, отправляя пакет с
соответствующей командой. Эту команду функция checkLoginPassword выдаёт в качестве результата, и в зависимости от
возвращённого значения, LoginController либо запускает основное окно программы, либо выдаёт диалог с
соответствующей информацией. Эта процедура позволяет не передавать в сеть пароль в открытом виде, а код запроса каждый
раз новый. В реальной программе алгоритм расчёта ответного кода можно усложнить, насколько этого будут требовать
условия безопасности. В моём примере он достаточно прост.
Проблема в том, что принимаются пакеты в другом потоке, и их содержимое обрабатывается отдельной функцией
commandExecutor в том же классе Connection. Соответственно, есть проблема, как из этой функции передать ответ сервера
в функцию checkLoginPаssword. Я реализовал так: в классе Connections ввёл отдельное поле loginCase класса LoginCases
(это enum, в котором хранятся возможные ответы от сервера на запрос клиента залогиниться). Функция checkLoginPassword
отправляет пакет с запросом залогиниться, ждёт одну секунду и проверяет значение поля loginCase. За это время клиент и
сервер успевают обменяться всей необходимой информацией, и функция commandExecutor меняет значение поля loginCase в
зависимости от ответа сервера. Понимаю, что это жуткий костыль. Как можно было бы сделать это правильно?

2. Обмен между сервером и клиентом происходит в виде объектов Java. Соответственно, на стороне клиента используются
ObjectDecoderInputStream и ObjectEncoderOutputStream, которые принадлежат к библиотеке Netty. Использовать
ObjectInputStream и ObjectOutputStream не получилось. Как сделать правильно? Оставить, как есть, либо исключить
вхождение классов Netty, и если второе, то как реализовать передачу объектов?

3. Для корректной работы JavaFX в настройках VMOptions в среде разработки у меня вписано:
-p /home/mnovikov37/.jdks/javafx-sdk-11.0.2/lib --add-modules javafx.controls,javafx.fxml Иначе FXLoader не работает
Эти параметры нужно будет куда-то вводить для окончательной компиляции проекта в jar, или эти параметры вообще нужно
вписать по-правильному в другое место? Например, в мавен. Пока собирать jar не пробовал, но вопрос вот такой возник.